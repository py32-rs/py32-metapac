#![allow(clippy::missing_safety_doc)]
                #![allow(clippy::identity_op)]
                #![allow(clippy::unnecessary_cast)]
                #![allow(clippy::erasing_op)]

# [doc = "Reset and clock control."]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Rcc { ptr : * mut u8 } unsafe impl Send for Rcc { } unsafe impl Sync for Rcc { } impl Rcc { # [inline (always)]
pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)]
pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Clock control register."]
# [inline (always)]
pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0usize) as _) } } # [doc = "Internal clock sources calibration register."]
# [inline (always)]
pub const fn icscr (self) -> crate :: common :: Reg < regs :: Icscr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x04usize) as _) } } # [doc = "Clock configuration register."]
# [inline (always)]
pub const fn cfgr (self) -> crate :: common :: Reg < regs :: Cfgr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x08usize) as _) } } # [doc = "PLL configuration register."]
# [inline (always)]
pub const fn pllcfgr (self) -> crate :: common :: Reg < regs :: Pllcfgr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0cusize) as _) } } # [doc = "External clock source control register."]
# [inline (always)]
pub const fn ecscr (self) -> crate :: common :: Reg < regs :: Ecscr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x10usize) as _) } } # [doc = "Clock interrupt enable register."]
# [inline (always)]
pub const fn cier (self) -> crate :: common :: Reg < regs :: Cier , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x18usize) as _) } } # [doc = "Clock interrupt flag register."]
# [inline (always)]
pub const fn cifr (self) -> crate :: common :: Reg < regs :: Cifr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x1cusize) as _) } } # [doc = "Clock interrupt clear register."]
# [inline (always)]
pub const fn cicr (self) -> crate :: common :: Reg < regs :: Cicr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x20usize) as _) } } # [doc = "GPIO reset register."]
# [inline (always)]
pub const fn ioprstr (self) -> crate :: common :: Reg < regs :: Ioprstr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x24usize) as _) } } # [doc = "AHB peripheral reset register."]
# [inline (always)]
pub const fn ahbrstr (self) -> crate :: common :: Reg < regs :: Ahbrstr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x28usize) as _) } } # [doc = "APB peripheral reset register. 1."]
# [inline (always)]
pub const fn apbrstr1 (self) -> crate :: common :: Reg < regs :: Apbrstr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x2cusize) as _) } } # [doc = "APB peripheral reset register. 2."]
# [inline (always)]
pub const fn apbrstr2 (self) -> crate :: common :: Reg < regs :: Apbrstr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x30usize) as _) } } # [doc = "GPIO clock enable register."]
# [inline (always)]
pub const fn iopenr (self) -> crate :: common :: Reg < regs :: Iopenr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x34usize) as _) } } # [doc = "AHB peripheral clock enable register."]
# [inline (always)]
pub const fn ahbenr (self) -> crate :: common :: Reg < regs :: Ahbenr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x38usize) as _) } } # [doc = "APB peripheral clock enable register. 1."]
# [inline (always)]
pub const fn apbenr1 (self) -> crate :: common :: Reg < regs :: Apbenr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x3cusize) as _) } } # [doc = "APB peripheral clock enable register. 2."]
# [inline (always)]
pub const fn apbenr2 (self) -> crate :: common :: Reg < regs :: Apbenr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x40usize) as _) } } # [doc = "Peripherals independent clock configuration register."]
# [inline (always)]
pub const fn ccipr (self) -> crate :: common :: Reg < regs :: Ccipr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x54usize) as _) } } # [doc = "RTC domain control register."]
# [inline (always)]
pub const fn bdcr (self) -> crate :: common :: Reg < regs :: Bdcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x5cusize) as _) } } # [doc = "Control/status register."]
# [inline (always)]
pub const fn csr (self) -> crate :: common :: Reg < regs :: Csr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x60usize) as _) } } } pub mod regs { # [doc = "AHB peripheral clock enable register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ahbenr (pub u32) ; impl Ahbenr { # [doc = "DMA clock enable."]
# [inline (always)]
pub const fn dmaen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "DMA clock enable."]
# [inline (always)]
pub fn set_dmaen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Flash memory interface clock. enable."]
# [inline (always)]
pub const fn flashen (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Flash memory interface clock. enable."]
# [inline (always)]
pub fn set_flashen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "SRAM memory interface clock. enable."]
# [inline (always)]
pub const fn sramen (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "SRAM memory interface clock. enable."]
# [inline (always)]
pub fn set_sramen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "CRC clock enable."]
# [inline (always)]
pub const fn crcen (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "CRC clock enable."]
# [inline (always)]
pub fn set_crcen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Ahbenr { # [inline (always)]
fn default () -> Ahbenr { Ahbenr (0) } } # [doc = "AHB peripheral reset register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ahbrstr (pub u32) ; impl Ahbrstr { # [doc = "DMA reset."]
# [inline (always)]
pub const fn dmarst (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "DMA reset."]
# [inline (always)]
pub fn set_dmarst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "CRC reset."]
# [inline (always)]
pub const fn crcrst (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "CRC reset."]
# [inline (always)]
pub fn set_crcrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Ahbrstr { # [inline (always)]
fn default () -> Ahbrstr { Ahbrstr (0) } } # [doc = "APB peripheral clock enable register. 1."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Apbenr1 (pub u32) ; impl Apbenr1 { # [doc = "TIM3 timer clock enable."]
# [inline (always)]
pub const fn tim3en (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "TIM3 timer clock enable."]
# [inline (always)]
pub fn set_tim3en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "RTC APB clock enable."]
# [inline (always)]
pub const fn rtcapben (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "RTC APB clock enable."]
# [inline (always)]
pub fn set_rtcapben (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "WWDG clock enable."]
# [inline (always)]
pub const fn wwdgen (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "WWDG clock enable."]
# [inline (always)]
pub fn set_wwdgen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "SPI2 clock enable."]
# [inline (always)]
pub const fn spi2en (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "SPI2 clock enable."]
# [inline (always)]
pub fn set_spi2en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "USART2 clock enable."]
# [inline (always)]
pub const fn usart2en (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "USART2 clock enable."]
# [inline (always)]
pub fn set_usart2en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "I2C clock enable."]
# [inline (always)]
pub const fn i2cen (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "I2C clock enable."]
# [inline (always)]
pub fn set_i2cen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } # [doc = "Debug support clock enable."]
# [inline (always)]
pub const fn dbgen (& self) -> bool { let val = (self . 0 >> 27usize) & 0x01 ; val != 0 } # [doc = "Debug support clock enable."]
# [inline (always)]
pub fn set_dbgen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize) ; } # [doc = "Power interface clock. enable."]
# [inline (always)]
pub const fn pwren (& self) -> bool { let val = (self . 0 >> 28usize) & 0x01 ; val != 0 } # [doc = "Power interface clock. enable."]
# [inline (always)]
pub fn set_pwren (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize) ; } # [doc = "LPTIM clock enable."]
# [inline (always)]
pub const fn lptimen (& self) -> bool { let val = (self . 0 >> 31usize) & 0x01 ; val != 0 } # [doc = "LPTIM clock enable."]
# [inline (always)]
pub fn set_lptimen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize) ; } } impl Default for Apbenr1 { # [inline (always)]
fn default () -> Apbenr1 { Apbenr1 (0) } } # [doc = "APB peripheral clock enable register. 2."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Apbenr2 (pub u32) ; impl Apbenr2 { # [doc = "SYSCFG, COMP and VREFBUF clock. enable."]
# [inline (always)]
pub const fn syscfgen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "SYSCFG, COMP and VREFBUF clock. enable."]
# [inline (always)]
pub fn set_syscfgen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "TIM1 timer clock enable."]
# [inline (always)]
pub const fn tim1en (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "TIM1 timer clock enable."]
# [inline (always)]
pub fn set_tim1en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "SPI1 clock enable."]
# [inline (always)]
pub const fn spi1en (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "SPI1 clock enable."]
# [inline (always)]
pub fn set_spi1en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "USART1 clock enable."]
# [inline (always)]
pub const fn usart1en (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "USART1 clock enable."]
# [inline (always)]
pub fn set_usart1en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "TIM14 timer clock enable."]
# [inline (always)]
pub const fn tim14en (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "TIM14 timer clock enable."]
# [inline (always)]
pub fn set_tim14en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "TIM16 timer clock enable."]
# [inline (always)]
pub const fn tim16en (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "TIM16 timer clock enable."]
# [inline (always)]
pub fn set_tim16en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "TIM16 timer clock enable."]
# [inline (always)]
pub const fn tim17en (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "TIM16 timer clock enable."]
# [inline (always)]
pub fn set_tim17en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "ADC clock enable."]
# [inline (always)]
pub const fn adcen (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "ADC clock enable."]
# [inline (always)]
pub fn set_adcen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "COMP1 clock enable."]
# [inline (always)]
pub const fn comp1en (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "COMP1 clock enable."]
# [inline (always)]
pub fn set_comp1en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } # [doc = "COMP2 clock enable."]
# [inline (always)]
pub const fn comp2en (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "COMP2 clock enable."]
# [inline (always)]
pub fn set_comp2en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "LED clock enable."]
# [inline (always)]
pub const fn leden (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "LED clock enable."]
# [inline (always)]
pub fn set_leden (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } } impl Default for Apbenr2 { # [inline (always)]
fn default () -> Apbenr2 { Apbenr2 (0) } } # [doc = "APB peripheral reset register. 1."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Apbrstr1 (pub u32) ; impl Apbrstr1 { # [doc = "TIM3 timer reset."]
# [inline (always)]
pub const fn tim3rst (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "TIM3 timer reset."]
# [inline (always)]
pub fn set_tim3rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "SPI2 reset."]
# [inline (always)]
pub const fn spi2rst (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "SPI2 reset."]
# [inline (always)]
pub fn set_spi2rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "USART2 reset."]
# [inline (always)]
pub const fn usart2rst (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "USART2 reset."]
# [inline (always)]
pub fn set_usart2rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "I2C reset."]
# [inline (always)]
pub const fn i2crst (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "I2C reset."]
# [inline (always)]
pub fn set_i2crst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } # [doc = "Debug support reset."]
# [inline (always)]
pub const fn dbgrst (& self) -> bool { let val = (self . 0 >> 27usize) & 0x01 ; val != 0 } # [doc = "Debug support reset."]
# [inline (always)]
pub fn set_dbgrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize) ; } # [doc = "Power interface reset."]
# [inline (always)]
pub const fn pwrrst (& self) -> bool { let val = (self . 0 >> 28usize) & 0x01 ; val != 0 } # [doc = "Power interface reset."]
# [inline (always)]
pub fn set_pwrrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize) ; } # [doc = "Low Power Timer reset."]
# [inline (always)]
pub const fn lptimrst (& self) -> bool { let val = (self . 0 >> 31usize) & 0x01 ; val != 0 } # [doc = "Low Power Timer reset."]
# [inline (always)]
pub fn set_lptimrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize) ; } } impl Default for Apbrstr1 { # [inline (always)]
fn default () -> Apbrstr1 { Apbrstr1 (0) } } # [doc = "APB peripheral reset register. 2."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Apbrstr2 (pub u32) ; impl Apbrstr2 { # [doc = "SYSCFG and COMP reset."]
# [inline (always)]
pub const fn syscfgrst (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "SYSCFG and COMP reset."]
# [inline (always)]
pub fn set_syscfgrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "TIM1 timer reset."]
# [inline (always)]
pub const fn tim1rst (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "TIM1 timer reset."]
# [inline (always)]
pub fn set_tim1rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "SPI1 reset."]
# [inline (always)]
pub const fn spi1rst (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "SPI1 reset."]
# [inline (always)]
pub fn set_spi1rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "USART1 reset."]
# [inline (always)]
pub const fn usart1rst (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "USART1 reset."]
# [inline (always)]
pub fn set_usart1rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "TIM14 timer reset."]
# [inline (always)]
pub const fn tim14rst (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "TIM14 timer reset."]
# [inline (always)]
pub fn set_tim14rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "TIM16 timer reset."]
# [inline (always)]
pub const fn tim16rst (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "TIM16 timer reset."]
# [inline (always)]
pub fn set_tim16rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "TIM17 timer reset."]
# [inline (always)]
pub const fn tim17rst (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "TIM17 timer reset."]
# [inline (always)]
pub fn set_tim17rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "ADC reset."]
# [inline (always)]
pub const fn adcrst (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "ADC reset."]
# [inline (always)]
pub fn set_adcrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "COMP1 reset."]
# [inline (always)]
pub const fn comp1rst (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "COMP1 reset."]
# [inline (always)]
pub fn set_comp1rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } # [doc = "COMP2 reset."]
# [inline (always)]
pub const fn comp2rst (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "COMP2 reset."]
# [inline (always)]
pub fn set_comp2rst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "LED reset."]
# [inline (always)]
pub const fn ledrst (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "LED reset."]
# [inline (always)]
pub fn set_ledrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } } impl Default for Apbrstr2 { # [inline (always)]
fn default () -> Apbrstr2 { Apbrstr2 (0) } } # [doc = "RTC domain control register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Bdcr (pub u32) ; impl Bdcr { # [doc = "LSE oscillator enable."]
# [inline (always)]
pub const fn lseon (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "LSE oscillator enable."]
# [inline (always)]
pub fn set_lseon (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "LSE oscillator ready."]
# [inline (always)]
pub const fn lserdy (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "LSE oscillator ready."]
# [inline (always)]
pub fn set_lserdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "LSE oscillator bypass."]
# [inline (always)]
pub const fn lsebyp (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "LSE oscillator bypass."]
# [inline (always)]
pub fn set_lsebyp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "LSE CSS enable."]
# [inline (always)]
pub const fn lsecsson (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "LSE CSS enable."]
# [inline (always)]
pub fn set_lsecsson (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "LSE CSS detect."]
# [inline (always)]
pub const fn lsecssd (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "LSE CSS detect."]
# [inline (always)]
pub fn set_lsecssd (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "RTC clock source selection."]
# [inline (always)]
pub const fn rtcsel (& self) -> super :: vals :: Rtcsel { let val = (self . 0 >> 8usize) & 0x03 ; super :: vals :: Rtcsel :: from_bits (val as u8) } # [doc = "RTC clock source selection."]
# [inline (always)]
pub fn set_rtcsel (& mut self , val : super :: vals :: Rtcsel) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val . to_bits () as u32) & 0x03) << 8usize) ; } # [doc = "RTC clock source enable."]
# [inline (always)]
pub const fn rtcen (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "RTC clock source enable."]
# [inline (always)]
pub fn set_rtcen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "RTC domain software reset."]
# [inline (always)]
pub const fn bdrst (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "RTC domain software reset."]
# [inline (always)]
pub fn set_bdrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Low-speed clock output (LSCO) enable."]
# [inline (always)]
pub const fn lscoen (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Low-speed clock output (LSCO) enable."]
# [inline (always)]
pub fn set_lscoen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } # [doc = "Low-speed clock output selection."]
# [inline (always)]
pub const fn lscosel (& self) -> bool { let val = (self . 0 >> 25usize) & 0x01 ; val != 0 } # [doc = "Low-speed clock output selection."]
# [inline (always)]
pub fn set_lscosel (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize) ; } } impl Default for Bdcr { # [inline (always)]
fn default () -> Bdcr { Bdcr (0) } } # [doc = "Peripherals independent clock configuration register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ccipr (pub u32) ; impl Ccipr { # [doc = "PVD detect clock source selection."]
# [inline (always)]
pub const fn pvdsel (& self) -> super :: vals :: Pvdsel { let val = (self . 0 >> 7usize) & 0x01 ; super :: vals :: Pvdsel :: from_bits (val as u8) } # [doc = "PVD detect clock source selection."]
# [inline (always)]
pub fn set_pvdsel (& mut self , val : super :: vals :: Pvdsel) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val . to_bits () as u32) & 0x01) << 7usize) ; } # [doc = "COMP1 clock source selection."]
# [inline (always)]
pub const fn comp1sel (& self) -> super :: vals :: Comp1sel { let val = (self . 0 >> 8usize) & 0x01 ; super :: vals :: Comp1sel :: from_bits (val as u8) } # [doc = "COMP1 clock source selection."]
# [inline (always)]
pub fn set_comp1sel (& mut self , val : super :: vals :: Comp1sel) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val . to_bits () as u32) & 0x01) << 8usize) ; } # [doc = "COMP2 clock source selection."]
# [inline (always)]
pub const fn comp2sel (& self) -> super :: vals :: Comp2sel { let val = (self . 0 >> 9usize) & 0x01 ; super :: vals :: Comp2sel :: from_bits (val as u8) } # [doc = "COMP2 clock source selection."]
# [inline (always)]
pub fn set_comp2sel (& mut self , val : super :: vals :: Comp2sel) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val . to_bits () as u32) & 0x01) << 9usize) ; } # [doc = "LPTIM1 clock source selection."]
# [inline (always)]
pub const fn lptim1sel (& self) -> super :: vals :: Lptim1sel { let val = (self . 0 >> 18usize) & 0x03 ; super :: vals :: Lptim1sel :: from_bits (val as u8) } # [doc = "LPTIM1 clock source selection."]
# [inline (always)]
pub fn set_lptim1sel (& mut self , val : super :: vals :: Lptim1sel) { self . 0 = (self . 0 & ! (0x03 << 18usize)) | (((val . to_bits () as u32) & 0x03) << 18usize) ; } } impl Default for Ccipr { # [inline (always)]
fn default () -> Ccipr { Ccipr (0) } } # [doc = "Clock configuration register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cfgr (pub u32) ; impl Cfgr { # [doc = "System clock switch."]
# [inline (always)]
pub const fn sw (& self) -> super :: vals :: Sw { let val = (self . 0 >> 0usize) & 0x07 ; super :: vals :: Sw :: from_bits (val as u8) } # [doc = "System clock switch."]
# [inline (always)]
pub fn set_sw (& mut self , val : super :: vals :: Sw) { self . 0 = (self . 0 & ! (0x07 << 0usize)) | (((val . to_bits () as u32) & 0x07) << 0usize) ; } # [doc = "System clock switch status."]
# [inline (always)]
pub const fn sws (& self) -> super :: vals :: Sw { let val = (self . 0 >> 3usize) & 0x07 ; super :: vals :: Sw :: from_bits (val as u8) } # [doc = "System clock switch status."]
# [inline (always)]
pub fn set_sws (& mut self , val : super :: vals :: Sw) { self . 0 = (self . 0 & ! (0x07 << 3usize)) | (((val . to_bits () as u32) & 0x07) << 3usize) ; } # [doc = "AHB prescaler."]
# [inline (always)]
pub const fn hpre (& self) -> super :: vals :: Hpre { let val = (self . 0 >> 8usize) & 0x0f ; super :: vals :: Hpre :: from_bits (val as u8) } # [doc = "AHB prescaler."]
# [inline (always)]
pub fn set_hpre (& mut self , val : super :: vals :: Hpre) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val . to_bits () as u32) & 0x0f) << 8usize) ; } # [doc = "APB prescaler."]
# [inline (always)]
pub const fn ppre (& self) -> super :: vals :: Ppre { let val = (self . 0 >> 12usize) & 0x07 ; super :: vals :: Ppre :: from_bits (val as u8) } # [doc = "APB prescaler."]
# [inline (always)]
pub fn set_ppre (& mut self , val : super :: vals :: Ppre) { self . 0 = (self . 0 & ! (0x07 << 12usize)) | (((val . to_bits () as u32) & 0x07) << 12usize) ; } # [doc = "Microcontroller clock. output."]
# [inline (always)]
pub const fn mcosel (& self) -> super :: vals :: Mcosel { let val = (self . 0 >> 24usize) & 0x07 ; super :: vals :: Mcosel :: from_bits (val as u8) } # [doc = "Microcontroller clock. output."]
# [inline (always)]
pub fn set_mcosel (& mut self , val : super :: vals :: Mcosel) { self . 0 = (self . 0 & ! (0x07 << 24usize)) | (((val . to_bits () as u32) & 0x07) << 24usize) ; } # [doc = "Microcontroller clock output. prescaler."]
# [inline (always)]
pub const fn mcopre (& self) -> super :: vals :: Mcopre { let val = (self . 0 >> 28usize) & 0x07 ; super :: vals :: Mcopre :: from_bits (val as u8) } # [doc = "Microcontroller clock output. prescaler."]
# [inline (always)]
pub fn set_mcopre (& mut self , val : super :: vals :: Mcopre) { self . 0 = (self . 0 & ! (0x07 << 28usize)) | (((val . to_bits () as u32) & 0x07) << 28usize) ; } } impl Default for Cfgr { # [inline (always)]
fn default () -> Cfgr { Cfgr (0) } } # [doc = "Clock interrupt clear register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cicr (pub u32) ; impl Cicr { # [doc = "LSI ready interrupt clear."]
# [inline (always)]
pub const fn lsirdyc (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "LSI ready interrupt clear."]
# [inline (always)]
pub fn set_lsirdyc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "LSE ready interrupt clear."]
# [inline (always)]
pub const fn lserdyc (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "LSE ready interrupt clear."]
# [inline (always)]
pub fn set_lserdyc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "HSI ready interrupt clear."]
# [inline (always)]
pub const fn hsirdyc (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "HSI ready interrupt clear."]
# [inline (always)]
pub fn set_hsirdyc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "HSE ready interrupt clear."]
# [inline (always)]
pub const fn hserdyc (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "HSE ready interrupt clear."]
# [inline (always)]
pub fn set_hserdyc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "PLL ready interrupt clear."]
# [inline (always)]
pub const fn pllrdyc (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "PLL ready interrupt clear."]
# [inline (always)]
pub fn set_pllrdyc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "clock secure system interrupt flag clear."]
# [inline (always)]
pub const fn cssc (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "clock secure system interrupt flag clear."]
# [inline (always)]
pub fn set_cssc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "LSE clock secure system interrupt flag clear."]
# [inline (always)]
pub const fn lsecssc (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "LSE clock secure system interrupt flag clear."]
# [inline (always)]
pub fn set_lsecssc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } } impl Default for Cicr { # [inline (always)]
fn default () -> Cicr { Cicr (0) } } # [doc = "Clock interrupt enable register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cier (pub u32) ; impl Cier { # [doc = "LSI ready interrupt enable."]
# [inline (always)]
pub const fn lsirdyie (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "LSI ready interrupt enable."]
# [inline (always)]
pub fn set_lsirdyie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "LSE ready interrupt enable."]
# [inline (always)]
pub const fn lserdyie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "LSE ready interrupt enable."]
# [inline (always)]
pub fn set_lserdyie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "HSI ready interrupt enable."]
# [inline (always)]
pub const fn hsirdyie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "HSI ready interrupt enable."]
# [inline (always)]
pub fn set_hsirdyie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "HSE ready interrupt enable."]
# [inline (always)]
pub const fn hserdyie (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "HSE ready interrupt enable."]
# [inline (always)]
pub fn set_hserdyie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "PLL ready interrupt enable."]
# [inline (always)]
pub const fn pllrdyie (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "PLL ready interrupt enable."]
# [inline (always)]
pub fn set_pllrdyie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } } impl Default for Cier { # [inline (always)]
fn default () -> Cier { Cier (0) } } # [doc = "Clock interrupt flag register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cifr (pub u32) ; impl Cifr { # [doc = "LSI ready interrupt flag."]
# [inline (always)]
pub const fn lsirdyf (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "LSI ready interrupt flag."]
# [inline (always)]
pub fn set_lsirdyf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "LSE ready interrupt flag."]
# [inline (always)]
pub const fn lserdyf (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "LSE ready interrupt flag."]
# [inline (always)]
pub fn set_lserdyf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "HSI ready interrupt flag."]
# [inline (always)]
pub const fn hsirdyf (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "HSI ready interrupt flag."]
# [inline (always)]
pub fn set_hsirdyf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "HSE ready interrupt flag."]
# [inline (always)]
pub const fn hserdyf (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "HSE ready interrupt flag."]
# [inline (always)]
pub fn set_hserdyf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "PLL ready interrupt flag."]
# [inline (always)]
pub const fn pllrdyf (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "PLL ready interrupt flag."]
# [inline (always)]
pub fn set_pllrdyf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "HSE clock secure system interrupt flag."]
# [inline (always)]
pub const fn cssf (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "HSE clock secure system interrupt flag."]
# [inline (always)]
pub fn set_cssf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "LSE clock secure system interrupt flag."]
# [inline (always)]
pub const fn lsecssf (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "LSE clock secure system interrupt flag."]
# [inline (always)]
pub fn set_lsecssf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } } impl Default for Cifr { # [inline (always)]
fn default () -> Cifr { Cifr (0) } } # [doc = "Clock control register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cr (pub u32) ; impl Cr { # [doc = "HSI16 clock enable."]
# [inline (always)]
pub const fn hsion (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "HSI16 clock enable."]
# [inline (always)]
pub fn set_hsion (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "HSI16 always enable for peripheral. kernels."]
# [inline (always)]
pub const fn hsikeron (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "HSI16 always enable for peripheral. kernels."]
# [inline (always)]
pub fn set_hsikeron (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "HSI16 clock ready flag."]
# [inline (always)]
pub const fn hsirdy (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "HSI16 clock ready flag."]
# [inline (always)]
pub fn set_hsirdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "HSI16 clock division. factor."]
# [inline (always)]
pub const fn hsidiv (& self) -> super :: vals :: Hsidiv { let val = (self . 0 >> 11usize) & 0x07 ; super :: vals :: Hsidiv :: from_bits (val as u8) } # [doc = "HSI16 clock division. factor."]
# [inline (always)]
pub fn set_hsidiv (& mut self , val : super :: vals :: Hsidiv) { self . 0 = (self . 0 & ! (0x07 << 11usize)) | (((val . to_bits () as u32) & 0x07) << 11usize) ; } # [doc = "HSE clock enable."]
# [inline (always)]
pub const fn hseon (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "HSE clock enable."]
# [inline (always)]
pub fn set_hseon (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "HSE clock ready flag."]
# [inline (always)]
pub const fn hserdy (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "HSE clock ready flag."]
# [inline (always)]
pub fn set_hserdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "HSE crystal oscillator. bypass."]
# [inline (always)]
pub const fn hsebyp (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "HSE crystal oscillator. bypass."]
# [inline (always)]
pub fn set_hsebyp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "Clock security system. enable."]
# [inline (always)]
pub const fn csson (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Clock security system. enable."]
# [inline (always)]
pub fn set_csson (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "PLL enable."]
# [inline (always)]
pub const fn pllon (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "PLL enable."]
# [inline (always)]
pub fn set_pllon (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } # [doc = "PLL clock ready flag."]
# [inline (always)]
pub const fn pllrdy (& self) -> bool { let val = (self . 0 >> 25usize) & 0x01 ; val != 0 } # [doc = "PLL clock ready flag."]
# [inline (always)]
pub fn set_pllrdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize) ; } } impl Default for Cr { # [inline (always)]
fn default () -> Cr { Cr (0) } } # [doc = "Control/status register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Csr (pub u32) ; impl Csr { # [doc = "LSI oscillator enable."]
# [inline (always)]
pub const fn lsion (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "LSI oscillator enable."]
# [inline (always)]
pub fn set_lsion (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "LSI oscillator ready."]
# [inline (always)]
pub const fn lsirdy (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "LSI oscillator ready."]
# [inline (always)]
pub fn set_lsirdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Remove reset flags."]
# [inline (always)]
pub const fn rmvf (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "Remove reset flags."]
# [inline (always)]
pub fn set_rmvf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } # [doc = "Option byte loader reset. flag."]
# [inline (always)]
pub const fn oblrstf (& self) -> bool { let val = (self . 0 >> 25usize) & 0x01 ; val != 0 } # [doc = "Option byte loader reset. flag."]
# [inline (always)]
pub fn set_oblrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize) ; } # [doc = "Pin reset flag."]
# [inline (always)]
pub const fn pinrstf (& self) -> bool { let val = (self . 0 >> 26usize) & 0x01 ; val != 0 } # [doc = "Pin reset flag."]
# [inline (always)]
pub fn set_pinrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize) ; } # [doc = "BOR or POR/PDR flag."]
# [inline (always)]
pub const fn pwrrstf (& self) -> bool { let val = (self . 0 >> 27usize) & 0x01 ; val != 0 } # [doc = "BOR or POR/PDR flag."]
# [inline (always)]
pub fn set_pwrrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize) ; } # [doc = "Software reset flag."]
# [inline (always)]
pub const fn sftrstf (& self) -> bool { let val = (self . 0 >> 28usize) & 0x01 ; val != 0 } # [doc = "Software reset flag."]
# [inline (always)]
pub fn set_sftrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize) ; } # [doc = "Independent window watchdog reset. flag."]
# [inline (always)]
pub const fn iwdgrstf (& self) -> bool { let val = (self . 0 >> 29usize) & 0x01 ; val != 0 } # [doc = "Independent window watchdog reset. flag."]
# [inline (always)]
pub fn set_iwdgrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize) ; } # [doc = "Window watchdog reset flag."]
# [inline (always)]
pub const fn wwdgrstf (& self) -> bool { let val = (self . 0 >> 30usize) & 0x01 ; val != 0 } # [doc = "Window watchdog reset flag."]
# [inline (always)]
pub fn set_wwdgrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize) ; } } impl Default for Csr { # [inline (always)]
fn default () -> Csr { Csr (0) } } # [doc = "External clock source control register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ecscr (pub u32) ; impl Ecscr { # [doc = "HSE clock freqency selection."]
# [inline (always)]
pub const fn hse_freq (& self) -> super :: vals :: HseFreq { let val = (self . 0 >> 2usize) & 0x03 ; super :: vals :: HseFreq :: from_bits (val as u8) } # [doc = "HSE clock freqency selection."]
# [inline (always)]
pub fn set_hse_freq (& mut self , val : super :: vals :: HseFreq) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val . to_bits () as u32) & 0x03) << 2usize) ; } # [doc = "LSE clock driver selection."]
# [inline (always)]
pub const fn lse_driver (& self) -> super :: vals :: LseDriver { let val = (self . 0 >> 16usize) & 0x03 ; super :: vals :: LseDriver :: from_bits (val as u8) } # [doc = "LSE clock driver selection."]
# [inline (always)]
pub fn set_lse_driver (& mut self , val : super :: vals :: LseDriver) { self . 0 = (self . 0 & ! (0x03 << 16usize)) | (((val . to_bits () as u32) & 0x03) << 16usize) ; } } impl Default for Ecscr { # [inline (always)]
fn default () -> Ecscr { Ecscr (0) } } # [doc = "Internal clock sources calibration register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Icscr (pub u32) ; impl Icscr { # [doc = "HSI clock trimming."]
# [inline (always)]
pub const fn hsi_trim (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x1fff ; val as u16 } # [doc = "HSI clock trimming."]
# [inline (always)]
pub fn set_hsi_trim (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize) ; } # [doc = "HSI frequency selection."]
# [inline (always)]
pub const fn hsi_fs (& self) -> super :: vals :: HsiFs { let val = (self . 0 >> 13usize) & 0x07 ; super :: vals :: HsiFs :: from_bits (val as u8) } # [doc = "HSI frequency selection."]
# [inline (always)]
pub fn set_hsi_fs (& mut self , val : super :: vals :: HsiFs) { self . 0 = (self . 0 & ! (0x07 << 13usize)) | (((val . to_bits () as u32) & 0x07) << 13usize) ; } # [doc = "LSI clock trimming."]
# [inline (always)]
pub const fn lsi_trim (& self) -> u16 { let val = (self . 0 >> 16usize) & 0x01ff ; val as u16 } # [doc = "LSI clock trimming."]
# [inline (always)]
pub fn set_lsi_trim (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x01ff << 16usize)) | (((val as u32) & 0x01ff) << 16usize) ; } # [doc = "LSI startup time."]
# [inline (always)]
pub const fn lsi_startup (& self) -> super :: vals :: LsiStartup { let val = (self . 0 >> 26usize) & 0x03 ; super :: vals :: LsiStartup :: from_bits (val as u8) } # [doc = "LSI startup time."]
# [inline (always)]
pub fn set_lsi_startup (& mut self , val : super :: vals :: LsiStartup) { self . 0 = (self . 0 & ! (0x03 << 26usize)) | (((val . to_bits () as u32) & 0x03) << 26usize) ; } } impl Default for Icscr { # [inline (always)]
fn default () -> Icscr { Icscr (0) } } # [doc = "GPIO clock enable register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Iopenr (pub u32) ; impl Iopenr { # [doc = "I/O port A clock enable."]
# [inline (always)]
pub const fn gpioaen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "I/O port A clock enable."]
# [inline (always)]
pub fn set_gpioaen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "I/O port B clock enable."]
# [inline (always)]
pub const fn gpioben (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "I/O port B clock enable."]
# [inline (always)]
pub fn set_gpioben (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "I/O port F clock enable."]
# [inline (always)]
pub const fn gpiofen (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "I/O port F clock enable."]
# [inline (always)]
pub fn set_gpiofen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } } impl Default for Iopenr { # [inline (always)]
fn default () -> Iopenr { Iopenr (0) } } # [doc = "GPIO reset register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ioprstr (pub u32) ; impl Ioprstr { # [doc = "I/O port A reset."]
# [inline (always)]
pub const fn gpioarst (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "I/O port A reset."]
# [inline (always)]
pub fn set_gpioarst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "I/O port B reset."]
# [inline (always)]
pub const fn gpiobrst (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "I/O port B reset."]
# [inline (always)]
pub fn set_gpiobrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "I/O port F reset."]
# [inline (always)]
pub const fn gpiofrst (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "I/O port F reset."]
# [inline (always)]
pub fn set_gpiofrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } } impl Default for Ioprstr { # [inline (always)]
fn default () -> Ioprstr { Ioprstr (0) } } # [doc = "PLL configuration register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Pllcfgr (pub u32) ; impl Pllcfgr { # [doc = "PLL clock source selection."]
# [inline (always)]
pub const fn pllsrc (& self) -> super :: vals :: Pllsrc { let val = (self . 0 >> 0usize) & 0x01 ; super :: vals :: Pllsrc :: from_bits (val as u8) } # [doc = "PLL clock source selection."]
# [inline (always)]
pub fn set_pllsrc (& mut self , val : super :: vals :: Pllsrc) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val . to_bits () as u32) & 0x01) << 0usize) ; } } impl Default for Pllcfgr { # [inline (always)]
fn default () -> Pllcfgr { Pllcfgr (0) } } } pub mod vals { # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Comp1sel { # [doc = "PCLK selected as COMP1 clock source"]
PCLK = 0x0 , # [doc = "LSC selected as COMP1 clock source (selected by RCC_BDCR.LSCOSEL)"]
LSC = 0x01 , } impl Comp1sel { # [inline (always)]
pub const fn from_bits (val : u8) -> Comp1sel { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Comp1sel { # [inline (always)]
fn from (val : u8) -> Comp1sel { Comp1sel :: from_bits (val) } } impl From < Comp1sel > for u8 { # [inline (always)]
fn from (val : Comp1sel) -> u8 { Comp1sel :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Comp2sel { # [doc = "PCLK selected as COMP2 clock source"]
PCLK = 0x0 , # [doc = "LSC selected as COMP2 clock source (selected by RCC_BDCR.LSCOSEL)"]
LSC = 0x01 , } impl Comp2sel { # [inline (always)]
pub const fn from_bits (val : u8) -> Comp2sel { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Comp2sel { # [inline (always)]
fn from (val : u8) -> Comp2sel { Comp2sel :: from_bits (val) } } impl From < Comp2sel > for u8 { # [inline (always)]
fn from (val : Comp2sel) -> u8 { Comp2sel :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Hpre { # [doc = "SYSCLK not divided"]
DIV1 = 0x0 , _RESERVED_1 = 0x01 , _RESERVED_2 = 0x02 , _RESERVED_3 = 0x03 , _RESERVED_4 = 0x04 , _RESERVED_5 = 0x05 , _RESERVED_6 = 0x06 , _RESERVED_7 = 0x07 , # [doc = "SYSCLK divided by 2"]
DIV2 = 0x08 , # [doc = "SYSCLK divided by 4"]
DIV4 = 0x09 , # [doc = "SYSCLK divided by 8"]
DIV8 = 0x0a , # [doc = "SYSCLK divided by 16"]
DIV16 = 0x0b , # [doc = "SYSCLK divided by 64"]
DIV64 = 0x0c , # [doc = "SYSCLK divided by 128"]
DIV128 = 0x0d , # [doc = "SYSCLK divided by 256"]
DIV256 = 0x0e , # [doc = "SYSCLK divided by 512"]
DIV512 = 0x0f , } impl Hpre { # [inline (always)]
pub const fn from_bits (val : u8) -> Hpre { unsafe { core :: mem :: transmute (val & 0x0f) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Hpre { # [inline (always)]
fn from (val : u8) -> Hpre { Hpre :: from_bits (val) } } impl From < Hpre > for u8 { # [inline (always)]
fn from (val : Hpre) -> u8 { Hpre :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum HseFreq { # [doc = "HSE disabled"]
OFF = 0x0 , # [doc = "4MHz to 8MHz"]
RANGE1 = 0x01 , # [doc = "8MHz to 16MHz"]
RANGE2 = 0x02 , # [doc = "16MHz to 32MHz"]
RANGE3 = 0x03 , } impl HseFreq { # [inline (always)]
pub const fn from_bits (val : u8) -> HseFreq { unsafe { core :: mem :: transmute (val & 0x03) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for HseFreq { # [inline (always)]
fn from (val : u8) -> HseFreq { HseFreq :: from_bits (val) } } impl From < HseFreq > for u8 { # [inline (always)]
fn from (val : HseFreq) -> u8 { HseFreq :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum HsiFs { # [doc = "4MHz HSI frequency"]
HSI_4MHZ = 0x0 , # [doc = "8MHz HSI frequency"]
HSI_8MHZ = 0x01 , # [doc = "16MHz HSI frequency"]
HSI_16MHZ = 0x02 , # [doc = "22.12MHz HSI frequency"]
HSI_22_12MHZ = 0x03 , # [doc = "24MHz HSI frequency"]
HSI_24MHZ = 0x04 , _RESERVED_5 = 0x05 , _RESERVED_6 = 0x06 , _RESERVED_7 = 0x07 , } impl HsiFs { # [inline (always)]
pub const fn from_bits (val : u8) -> HsiFs { unsafe { core :: mem :: transmute (val & 0x07) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for HsiFs { # [inline (always)]
fn from (val : u8) -> HsiFs { HsiFs :: from_bits (val) } } impl From < HsiFs > for u8 { # [inline (always)]
fn from (val : HsiFs) -> u8 { HsiFs :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Hsidiv { # [doc = "HSI clock not divided"]
DIV1 = 0x0 , # [doc = "HSI clock divided by 2"]
DIV2 = 0x01 , # [doc = "HSI clock divided by 4"]
DIV4 = 0x02 , # [doc = "HSI clock divided by 8"]
DIV8 = 0x03 , # [doc = "HSI clock divided by 16"]
DIV16 = 0x04 , # [doc = "HSI clock divided by 32"]
DIV32 = 0x05 , # [doc = "HSI clock divided by 64"]
DIV64 = 0x06 , # [doc = "HSI clock divided by 128"]
DIV128 = 0x07 , } impl Hsidiv { # [inline (always)]
pub const fn from_bits (val : u8) -> Hsidiv { unsafe { core :: mem :: transmute (val & 0x07) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Hsidiv { # [inline (always)]
fn from (val : u8) -> Hsidiv { Hsidiv :: from_bits (val) } } impl From < Hsidiv > for u8 { # [inline (always)]
fn from (val : Hsidiv) -> u8 { Hsidiv :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Lptim1sel { # [doc = "PCLK selected as LPTIM1 clock source"]
PCLK = 0x0 , # [doc = "LSI selected as LPTIM1 clock source"]
LSI = 0x01 , # [doc = "No clock"]
NONE = 0x02 , # [doc = "LSE selected as LPTIM1 clock source"]
LSE = 0x03 , } impl Lptim1sel { # [inline (always)]
pub const fn from_bits (val : u8) -> Lptim1sel { unsafe { core :: mem :: transmute (val & 0x03) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Lptim1sel { # [inline (always)]
fn from (val : u8) -> Lptim1sel { Lptim1sel :: from_bits (val) } } impl From < Lptim1sel > for u8 { # [inline (always)]
fn from (val : Lptim1sel) -> u8 { Lptim1sel :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum LseDriver { # [doc = "LSE disabled"]
OFF = 0x0 , # [doc = "Weak drive capability (default)"]
LOW_POWER = 0x01 , # [doc = "Medium drive capability (recommended)"]
MEDIUM_POWER = 0x02 , # [doc = "Strong drive capability"]
HIGH_POWER = 0x03 , } impl LseDriver { # [inline (always)]
pub const fn from_bits (val : u8) -> LseDriver { unsafe { core :: mem :: transmute (val & 0x03) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for LseDriver { # [inline (always)]
fn from (val : u8) -> LseDriver { LseDriver :: from_bits (val) } } impl From < LseDriver > for u8 { # [inline (always)]
fn from (val : LseDriver) -> u8 { LseDriver :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum LsiStartup { # [doc = "4 LSI clock cycles startup time"]
CYCLES_4 = 0x0 , # [doc = "16 LSI clock cycles startup time"]
CYCLES_16 = 0x01 , # [doc = "64 LSI clock cycles startup time"]
CYCLES_64 = 0x02 , # [doc = "256 LSI clock cycles startup time"]
CYCLES_256 = 0x03 , } impl LsiStartup { # [inline (always)]
pub const fn from_bits (val : u8) -> LsiStartup { unsafe { core :: mem :: transmute (val & 0x03) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for LsiStartup { # [inline (always)]
fn from (val : u8) -> LsiStartup { LsiStartup :: from_bits (val) } } impl From < LsiStartup > for u8 { # [inline (always)]
fn from (val : LsiStartup) -> u8 { LsiStartup :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Mcopre { # [doc = "MCO clock not divided"]
DIV1 = 0x0 , # [doc = "MCO clock divided by 2"]
DIV2 = 0x01 , # [doc = "MCO clock divided by 4"]
DIV4 = 0x02 , # [doc = "MCO clock divided by 8"]
DIV8 = 0x03 , # [doc = "MCO clock divided by 16"]
DIV16 = 0x04 , # [doc = "MCO clock divided by 32"]
DIV32 = 0x05 , # [doc = "MCO clock divided by 64"]
DIV64 = 0x06 , # [doc = "MCO clock divided by 128"]
DIV128 = 0x07 , } impl Mcopre { # [inline (always)]
pub const fn from_bits (val : u8) -> Mcopre { unsafe { core :: mem :: transmute (val & 0x07) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Mcopre { # [inline (always)]
fn from (val : u8) -> Mcopre { Mcopre :: from_bits (val) } } impl From < Mcopre > for u8 { # [inline (always)]
fn from (val : Mcopre) -> u8 { Mcopre :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Mcosel { # [doc = "No clock, MCO output disabled"]
NONE = 0x0 , # [doc = "System clock selected"]
SYSCLK = 0x01 , _RESERVED_2 = 0x02 , # [doc = "HSI clock selected"]
HSI = 0x03 , # [doc = "HSE clock selected"]
HSE = 0x04 , # [doc = "PLL clock selected"]
PLL_CLK = 0x05 , # [doc = "LSI clock selected"]
LSI = 0x06 , # [doc = "LSE clock selected"]
LSE = 0x07 , } impl Mcosel { # [inline (always)]
pub const fn from_bits (val : u8) -> Mcosel { unsafe { core :: mem :: transmute (val & 0x07) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Mcosel { # [inline (always)]
fn from (val : u8) -> Mcosel { Mcosel :: from_bits (val) } } impl From < Mcosel > for u8 { # [inline (always)]
fn from (val : Mcosel) -> u8 { Mcosel :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Pllsrc { HSI = 0x0 , HSE = 0x01 , } impl Pllsrc { # [inline (always)]
pub const fn from_bits (val : u8) -> Pllsrc { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Pllsrc { # [inline (always)]
fn from (val : u8) -> Pllsrc { Pllsrc :: from_bits (val) } } impl From < Pllsrc > for u8 { # [inline (always)]
fn from (val : Pllsrc) -> u8 { Pllsrc :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Ppre { # [doc = "HCLK not divided"]
DIV1 = 0x0 , _RESERVED_1 = 0x01 , _RESERVED_2 = 0x02 , _RESERVED_3 = 0x03 , # [doc = "HCLK divided by 2"]
DIV2 = 0x04 , # [doc = "HCLK divided by 4"]
DIV4 = 0x05 , # [doc = "HCLK divided by 8"]
DIV8 = 0x06 , # [doc = "HCLK divided by 16"]
DIV16 = 0x07 , } impl Ppre { # [inline (always)]
pub const fn from_bits (val : u8) -> Ppre { unsafe { core :: mem :: transmute (val & 0x07) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Ppre { # [inline (always)]
fn from (val : u8) -> Ppre { Ppre :: from_bits (val) } } impl From < Ppre > for u8 { # [inline (always)]
fn from (val : Ppre) -> u8 { Ppre :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Pvdsel { # [doc = "PCLK selected as PVD detection clock source"]
PCLK = 0x0 , # [doc = "LSC selected as PVD detection clock source (selected by RCC_BDCR.LSCOSEL)"]
LSC = 0x01 , } impl Pvdsel { # [inline (always)]
pub const fn from_bits (val : u8) -> Pvdsel { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Pvdsel { # [inline (always)]
fn from (val : u8) -> Pvdsel { Pvdsel :: from_bits (val) } } impl From < Pvdsel > for u8 { # [inline (always)]
fn from (val : Pvdsel) -> u8 { Pvdsel :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Rtcsel { # [doc = "No clock"]
DISABLE = 0x0 , # [doc = "LSE oscillator clock used as RTC clock"]
LSE = 0x01 , # [doc = "LSI oscillator clock used as RTC clock"]
LSI = 0x02 , # [doc = "HSE oscillator clock divided by a prescaler used as RTC clock"]
HSE_DIV128 = 0x03 , } impl Rtcsel { # [inline (always)]
pub const fn from_bits (val : u8) -> Rtcsel { unsafe { core :: mem :: transmute (val & 0x03) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Rtcsel { # [inline (always)]
fn from (val : u8) -> Rtcsel { Rtcsel :: from_bits (val) } } impl From < Rtcsel > for u8 { # [inline (always)]
fn from (val : Rtcsel) -> u8 { Rtcsel :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Sw { # [doc = "HSI oscillator used as system clock"]
HSI = 0x0 , # [doc = "HSE oscillator used as system clock"]
HSE = 0x01 , # [doc = "PLL used as system clock"]
PLL = 0x02 , # [doc = "LSI oscillator used as system clock"]
LSI = 0x03 , # [doc = "LSE oscillator used as system clock"]
LSE = 0x04 , _RESERVED_5 = 0x05 , _RESERVED_6 = 0x06 , _RESERVED_7 = 0x07 , } impl Sw { # [inline (always)]
pub const fn from_bits (val : u8) -> Sw { unsafe { core :: mem :: transmute (val & 0x07) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Sw { # [inline (always)]
fn from (val : u8) -> Sw { Sw :: from_bits (val) } } impl From < Sw > for u8 { # [inline (always)]
fn from (val : Sw) -> u8 { Sw :: to_bits (val) } } }