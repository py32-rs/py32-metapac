#![allow(clippy::missing_safety_doc)]
                #![allow(clippy::identity_op)]
                #![allow(clippy::unnecessary_cast)]
                #![allow(clippy::erasing_op)]

# [doc = "Inter integrated circuit."]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct I2c { ptr : * mut u8 } unsafe impl Send for I2c { } unsafe impl Sync for I2c { } impl I2c { # [inline (always)]
pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)]
pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Control register 1."]
# [inline (always)]
pub const fn cr1 (self) -> crate :: common :: Reg < regs :: Cr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0usize) as _) } } # [doc = "Control register 2."]
# [inline (always)]
pub const fn cr2 (self) -> crate :: common :: Reg < regs :: Cr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x04usize) as _) } } # [doc = "Own address register 1."]
# [inline (always)]
pub const fn oar1 (self) -> crate :: common :: Reg < regs :: Oar1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x08usize) as _) } } # [doc = "Data register."]
# [inline (always)]
pub const fn dr (self) -> crate :: common :: Reg < regs :: Dr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x10usize) as _) } } # [doc = "Status register 1."]
# [inline (always)]
pub const fn sr1 (self) -> crate :: common :: Reg < regs :: Sr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x14usize) as _) } } # [doc = "Status register 2."]
# [inline (always)]
pub const fn sr2 (self) -> crate :: common :: Reg < regs :: Sr2 , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x18usize) as _) } } # [doc = "Clock control register."]
# [inline (always)]
pub const fn ccr (self) -> crate :: common :: Reg < regs :: Ccr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x1cusize) as _) } } # [doc = "TRISE register."]
# [inline (always)]
pub const fn trise (self) -> crate :: common :: Reg < regs :: Trise , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x20usize) as _) } } } pub mod regs { # [doc = "Clock control register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ccr (pub u32) ; impl Ccr { # [doc = "Clock control register in Fast/Standard mode (Master mode)."]
# [inline (always)]
pub const fn ccr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x0fff ; val as u16 } # [doc = "Clock control register in Fast/Standard mode (Master mode)."]
# [inline (always)]
pub fn set_ccr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize) ; } # [doc = "Fast mode duty cycle."]
# [inline (always)]
pub const fn duty (& self) -> super :: vals :: Duty { let val = (self . 0 >> 14usize) & 0x01 ; super :: vals :: Duty :: from_bits (val as u8) } # [doc = "Fast mode duty cycle."]
# [inline (always)]
pub fn set_duty (& mut self , val : super :: vals :: Duty) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val . to_bits () as u32) & 0x01) << 14usize) ; } # [doc = "I2C master mode selection."]
# [inline (always)]
pub const fn f_s (& self) -> super :: vals :: FS { let val = (self . 0 >> 15usize) & 0x01 ; super :: vals :: FS :: from_bits (val as u8) } # [doc = "I2C master mode selection."]
# [inline (always)]
pub fn set_f_s (& mut self , val : super :: vals :: FS) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val . to_bits () as u32) & 0x01) << 15usize) ; } } impl Default for Ccr { # [inline (always)]
fn default () -> Ccr { Ccr (0) } } # [doc = "Control register 1."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cr1 (pub u32) ; impl Cr1 { # [doc = "Peripheral enable."]
# [inline (always)]
pub const fn pe (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Peripheral enable."]
# [inline (always)]
pub fn set_pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "PEC enable."]
# [inline (always)]
pub const fn enpec (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "PEC enable."]
# [inline (always)]
pub fn set_enpec (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "General call enable."]
# [inline (always)]
pub const fn engc (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "General call enable."]
# [inline (always)]
pub fn set_engc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Clock stretching disable (Slave mode)."]
# [inline (always)]
pub const fn nostretch (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Clock stretching disable (Slave mode)."]
# [inline (always)]
pub fn set_nostretch (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Start generation."]
# [inline (always)]
pub const fn start (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Start generation."]
# [inline (always)]
pub fn set_start (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Stop generation."]
# [inline (always)]
pub const fn stop (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Stop generation."]
# [inline (always)]
pub fn set_stop (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Acknowledge enable."]
# [inline (always)]
pub const fn ack (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Acknowledge enable."]
# [inline (always)]
pub fn set_ack (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Acknowledge/PEC Position (for data reception)."]
# [inline (always)]
pub const fn pos (& self) -> super :: vals :: Pos { let val = (self . 0 >> 11usize) & 0x01 ; super :: vals :: Pos :: from_bits (val as u8) } # [doc = "Acknowledge/PEC Position (for data reception)."]
# [inline (always)]
pub fn set_pos (& mut self , val : super :: vals :: Pos) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val . to_bits () as u32) & 0x01) << 11usize) ; } # [doc = "Packet error checking."]
# [inline (always)]
pub const fn pec (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Packet error checking."]
# [inline (always)]
pub fn set_pec (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Software reset."]
# [inline (always)]
pub const fn swrst (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Software reset."]
# [inline (always)]
pub fn set_swrst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Cr1 { # [inline (always)]
fn default () -> Cr1 { Cr1 (0) } } # [doc = "Control register 2."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cr2 (pub u32) ; impl Cr2 { # [doc = "Peripheral clock frequency."]
# [inline (always)]
pub const fn freq (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x3f ; val as u8 } # [doc = "Peripheral clock frequency."]
# [inline (always)]
pub fn set_freq (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize) ; } # [doc = "Error interrupt enable."]
# [inline (always)]
pub const fn iterren (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Error interrupt enable."]
# [inline (always)]
pub fn set_iterren (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Event interrupt enable."]
# [inline (always)]
pub const fn itevten (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Event interrupt enable."]
# [inline (always)]
pub fn set_itevten (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Buffer interrupt enable."]
# [inline (always)]
pub const fn itbufen (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Buffer interrupt enable."]
# [inline (always)]
pub fn set_itbufen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "DMA requests enable."]
# [inline (always)]
pub const fn dmaen (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "DMA requests enable."]
# [inline (always)]
pub fn set_dmaen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "DMA last transfer."]
# [inline (always)]
pub const fn last (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "DMA last transfer."]
# [inline (always)]
pub fn set_last (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Cr2 { # [inline (always)]
fn default () -> Cr2 { Cr2 (0) } } # [doc = "Data register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Dr (pub u32) ; impl Dr { # [doc = "8-bit data register."]
# [inline (always)]
pub const fn dr (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "8-bit data register."]
# [inline (always)]
pub fn set_dr (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Dr { # [inline (always)]
fn default () -> Dr { Dr (0) } } # [doc = "Own address register 1."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Oar1 (pub u32) ; impl Oar1 { # [doc = "Interface address."]
# [inline (always)]
pub const fn add (& self) -> u8 { let val = (self . 0 >> 1usize) & 0x7f ; val as u8 } # [doc = "Interface address."]
# [inline (always)]
pub fn set_add (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x7f << 1usize)) | (((val as u32) & 0x7f) << 1usize) ; } } impl Default for Oar1 { # [inline (always)]
fn default () -> Oar1 { Oar1 (0) } } # [doc = "Status register 1."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Sr1 (pub u32) ; impl Sr1 { # [doc = "Start bit (Master mode)"]
# [inline (always)]
pub const fn start (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Start bit (Master mode)"]
# [inline (always)]
pub fn set_start (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Address sent (master mode)/matched (slave mode)."]
# [inline (always)]
pub const fn addr (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Address sent (master mode)/matched (slave mode)."]
# [inline (always)]
pub fn set_addr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Byte transfer finished."]
# [inline (always)]
pub const fn btf (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Byte transfer finished."]
# [inline (always)]
pub fn set_btf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Stop detection (slave mode)."]
# [inline (always)]
pub const fn stopf (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Stop detection (slave mode)."]
# [inline (always)]
pub fn set_stopf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Data register not empty (receivers)"]
# [inline (always)]
pub const fn rxne (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Data register not empty (receivers)"]
# [inline (always)]
pub fn set_rxne (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Data register empty (transmitters)"]
# [inline (always)]
pub const fn txe (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Data register empty (transmitters)"]
# [inline (always)]
pub fn set_txe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Bus error."]
# [inline (always)]
pub const fn berr (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Bus error."]
# [inline (always)]
pub fn set_berr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Arbitration lost (master mode)."]
# [inline (always)]
pub const fn arlo (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Arbitration lost (master mode)."]
# [inline (always)]
pub fn set_arlo (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Acknowledge failure."]
# [inline (always)]
pub const fn af (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Acknowledge failure."]
# [inline (always)]
pub fn set_af (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Overrun/Underrun."]
# [inline (always)]
pub const fn ovr (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Overrun/Underrun."]
# [inline (always)]
pub fn set_ovr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "PEC Error in reception."]
# [inline (always)]
pub const fn pecerr (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "PEC Error in reception."]
# [inline (always)]
pub fn set_pecerr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Sr1 { # [inline (always)]
fn default () -> Sr1 { Sr1 (0) } } # [doc = "Status register 2."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Sr2 (pub u32) ; impl Sr2 { # [doc = "Master/slave."]
# [inline (always)]
pub const fn msl (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Master/slave."]
# [inline (always)]
pub fn set_msl (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Bus busy."]
# [inline (always)]
pub const fn busy (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Bus busy."]
# [inline (always)]
pub fn set_busy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Transmitter/receiver."]
# [inline (always)]
pub const fn tra (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Transmitter/receiver."]
# [inline (always)]
pub fn set_tra (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "General call address (Slave mode)."]
# [inline (always)]
pub const fn gencall (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "General call address (Slave mode)."]
# [inline (always)]
pub fn set_gencall (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Dual flag (Slave mode)."]
# [inline (always)]
pub const fn dualf (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Dual flag (Slave mode)."]
# [inline (always)]
pub fn set_dualf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "acket error checking register."]
# [inline (always)]
pub const fn pec (& self) -> u8 { let val = (self . 0 >> 8usize) & 0xff ; val as u8 } # [doc = "acket error checking register."]
# [inline (always)]
pub fn set_pec (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 8usize)) | (((val as u32) & 0xff) << 8usize) ; } } impl Default for Sr2 { # [inline (always)]
fn default () -> Sr2 { Sr2 (0) } } # [doc = "TRISE register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Trise (pub u32) ; impl Trise { # [doc = "Maximum rise time in Fast/Standard mode (Master mode)."]
# [inline (always)]
pub const fn trise (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x3f ; val as u8 } # [doc = "Maximum rise time in Fast/Standard mode (Master mode)."]
# [inline (always)]
pub fn set_trise (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize) ; } } impl Default for Trise { # [inline (always)]
fn default () -> Trise { Trise (0) } } } pub mod vals { # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Duty { # [doc = "Duty cycle t_low/t_high = 2/1"]
DUTY2_1 = 0x0 , # [doc = "Duty cycle t_low/t_high = 16/9"]
DUTY16_9 = 0x01 , } impl Duty { # [inline (always)]
pub const fn from_bits (val : u8) -> Duty { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Duty { # [inline (always)]
fn from (val : u8) -> Duty { Duty :: from_bits (val) } } impl From < Duty > for u8 { # [inline (always)]
fn from (val : Duty) -> u8 { Duty :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum FS { # [doc = "Standard mode I2C"]
STANDARD = 0x0 , # [doc = "Fast mode I2C"]
FAST = 0x01 , } impl FS { # [inline (always)]
pub const fn from_bits (val : u8) -> FS { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for FS { # [inline (always)]
fn from (val : u8) -> FS { FS :: from_bits (val) } } impl From < FS > for u8 { # [inline (always)]
fn from (val : FS) -> u8 { FS :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Pos { # [doc = "ACK bit controls the (N)ACK of the current byte being received"]
CURRENT = 0x0 , # [doc = "ACK bit controls the (N)ACK of the next byte to be received"]
NEXT = 0x01 , } impl Pos { # [inline (always)]
pub const fn from_bits (val : u8) -> Pos { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Pos { # [inline (always)]
fn from (val : u8) -> Pos { Pos :: from_bits (val) } } impl From < Pos > for u8 { # [inline (always)]
fn from (val : Pos) -> u8 { Pos :: to_bits (val) } } }