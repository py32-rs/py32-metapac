#![allow(clippy::missing_safety_doc)]
                #![allow(clippy::identity_op)]
                #![allow(clippy::unnecessary_cast)]
                #![allow(clippy::erasing_op)]

# [doc = "System configuration controller."]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Syscfg { ptr : * mut u8 } unsafe impl Send for Syscfg { } unsafe impl Sync for Syscfg { } impl Syscfg { # [inline (always)]
pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)]
pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "SYSCFG configuration register. 1."]
# [inline (always)]
pub const fn cfgr1 (self) -> crate :: common :: Reg < regs :: Cfgr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0usize) as _) } } # [doc = "SYSCFG configuration register. 2."]
# [inline (always)]
pub const fn cfgr2 (self) -> crate :: common :: Reg < regs :: Cfgr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x18usize) as _) } } # [doc = "SYSCFG configuration register. 3."]
# [inline (always)]
pub const fn cfgr3 (self) -> crate :: common :: Reg < regs :: Cfgr3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x1cusize) as _) } } } pub mod regs { # [doc = "SYSCFG configuration register. 1."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cfgr1 (pub u32) ; impl Cfgr1 { # [doc = "Memory mapping selection. bits."]
# [inline (always)]
pub const fn mem_mode (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Memory mapping selection. bits."]
# [inline (always)]
pub fn set_mem_mode (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PA2."]
# [inline (always)]
pub const fn i2c_pa2_anf (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PA2."]
# [inline (always)]
pub fn set_i2c_pa2_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PA3."]
# [inline (always)]
pub const fn i2c_pa3_anf (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PA3."]
# [inline (always)]
pub fn set_i2c_pa3_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PA7."]
# [inline (always)]
pub const fn i2c_pa7_anf (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PA7."]
# [inline (always)]
pub fn set_i2c_pa7_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PA8."]
# [inline (always)]
pub const fn i2c_pa8_anf (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PA8."]
# [inline (always)]
pub fn set_i2c_pa8_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PA9."]
# [inline (always)]
pub const fn i2c_pa9_anf (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PA9."]
# [inline (always)]
pub fn set_i2c_pa9_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PA10."]
# [inline (always)]
pub const fn i2c_pa10_anf (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PA10."]
# [inline (always)]
pub fn set_i2c_pa10_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PA11."]
# [inline (always)]
pub const fn i2c_pa11_anf (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PA11."]
# [inline (always)]
pub fn set_i2c_pa11_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PA12."]
# [inline (always)]
pub const fn i2c_pa12_anf (& self) -> bool { let val = (self . 0 >> 25usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PA12."]
# [inline (always)]
pub fn set_i2c_pa12_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PB6."]
# [inline (always)]
pub const fn i2c_pb6_anf (& self) -> bool { let val = (self . 0 >> 26usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PB6."]
# [inline (always)]
pub fn set_i2c_pb6_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PB7."]
# [inline (always)]
pub const fn i2c_pb7_anf (& self) -> bool { let val = (self . 0 >> 27usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PB7."]
# [inline (always)]
pub fn set_i2c_pb7_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PB8."]
# [inline (always)]
pub const fn i2c_pb8_anf (& self) -> bool { let val = (self . 0 >> 28usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PB8."]
# [inline (always)]
pub fn set_i2c_pb8_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PF0."]
# [inline (always)]
pub const fn i2c_pf0_anf (& self) -> bool { let val = (self . 0 >> 29usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PF0."]
# [inline (always)]
pub fn set_i2c_pf0_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize) ; } # [doc = "Analog filter enable control driving capability. activation bits PF1."]
# [inline (always)]
pub const fn i2c_pf1_anf (& self) -> bool { let val = (self . 0 >> 30usize) & 0x01 ; val != 0 } # [doc = "Analog filter enable control driving capability. activation bits PF1."]
# [inline (always)]
pub fn set_i2c_pf1_anf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize) ; } } impl Default for Cfgr1 { # [inline (always)]
fn default () -> Cfgr1 { Cfgr1 (0) } } # [doc = "SYSCFG configuration register. 2."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cfgr2 (pub u32) ; impl Cfgr2 { # [doc = "Cortex-M0+ LOCKUP bit enable. bit."]
# [inline (always)]
pub const fn lockup_lock (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Cortex-M0+ LOCKUP bit enable. bit."]
# [inline (always)]
pub fn set_lockup_lock (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "PVD lock enable bit."]
# [inline (always)]
pub const fn pvd_lock (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "PVD lock enable bit."]
# [inline (always)]
pub fn set_pvd_lock (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "COMP1 is enable to input of TIM1 break."]
# [inline (always)]
pub const fn comp1_brk_tim1 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "COMP1 is enable to input of TIM1 break."]
# [inline (always)]
pub fn set_comp1_brk_tim1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "COMP2 is enable to input of TIM1 break."]
# [inline (always)]
pub const fn comp2_brk_tim1 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "COMP2 is enable to input of TIM1 break."]
# [inline (always)]
pub fn set_comp2_brk_tim1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "COMP1 is enable to input of TIM16 break."]
# [inline (always)]
pub const fn comp1_brk_tim16 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "COMP1 is enable to input of TIM16 break."]
# [inline (always)]
pub fn set_comp1_brk_tim16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "COMP2 is enable to input of TIM16 break."]
# [inline (always)]
pub const fn comp2_brk_tim16 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "COMP2 is enable to input of TIM16 break."]
# [inline (always)]
pub fn set_comp2_brk_tim16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "COMP1 is enable to input of TIM17 break."]
# [inline (always)]
pub const fn comp1_brk_tim17 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "COMP1 is enable to input of TIM17 break."]
# [inline (always)]
pub fn set_comp1_brk_tim17 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "COMP2 is enable to input of TIM17 break."]
# [inline (always)]
pub const fn comp2_brk_tim17 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "COMP2 is enable to input of TIM17 break."]
# [inline (always)]
pub fn set_comp2_brk_tim17 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "TIM1 ETR source selection."]
# [inline (always)]
pub const fn etr_src_tim1 (& self) -> u8 { let val = (self . 0 >> 9usize) & 0x03 ; val as u8 } # [doc = "TIM1 ETR source selection."]
# [inline (always)]
pub fn set_etr_src_tim1 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 9usize)) | (((val as u32) & 0x03) << 9usize) ; } } impl Default for Cfgr2 { # [inline (always)]
fn default () -> Cfgr2 { Cfgr2 (0) } } # [doc = "SYSCFG configuration register 3."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Cfgr3 (pub u32) ; impl Cfgr3 { # [doc = "DMA channel x requeset selection."]
# [inline (always)]
pub const fn dma_map (& self , n : usize) -> u8 { assert ! (n < 3usize) ; let offs = 0usize + n * 8usize ; let val = (self . 0 >> offs) & 0x1f ; val as u8 } # [doc = "DMA channel x requeset selection."]
# [inline (always)]
pub fn set_dma_map (& mut self , n : usize , val : u8) { assert ! (n < 3usize) ; let offs = 0usize + n * 8usize ; self . 0 = (self . 0 & ! (0x1f << offs)) | (((val as u32) & 0x1f) << offs) ; } } impl Default for Cfgr3 { # [inline (always)]
fn default () -> Cfgr3 { Cfgr3 (0) } } }