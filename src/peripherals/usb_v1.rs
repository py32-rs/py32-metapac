#![allow(clippy::missing_safety_doc)]
                #![allow(clippy::identity_op)]
                #![allow(clippy::unnecessary_cast)]
                #![allow(clippy::erasing_op)]

# [doc = "USB control and status registers for managing USB operations."]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Usb { ptr : * mut u8 } unsafe impl Send for Usb { } unsafe impl Sync for Usb { } impl Usb { # [inline (always)]
pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)]
pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Function address of the USB device."]
# [inline (always)]
pub const fn addr (self) -> crate :: common :: Reg < regs :: Addr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0usize) as _) } } # [doc = "USB power management register."]
# [inline (always)]
pub const fn power (self) -> crate :: common :: Reg < regs :: Power , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x01usize) as _) } } # [doc = "USB interrupt status register."]
# [inline (always)]
pub const fn int_usb (self) -> crate :: common :: Reg < regs :: IntUsb , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x04usize) as _) } } # [doc = "Interrupt status for OUT endpoint 1."]
# [inline (always)]
pub const fn int_out1 (self) -> crate :: common :: Reg < regs :: IntOut1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x05usize) as _) } } # [doc = "Interrupt status for IN endpoint 1."]
# [inline (always)]
pub const fn int_in1 (self) -> crate :: common :: Reg < regs :: IntIn1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x06usize) as _) } } # [doc = "USB interrupt enable register."]
# [inline (always)]
pub const fn int_usbe (self) -> crate :: common :: Reg < regs :: IntUsb , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x08usize) as _) } } # [doc = "Interrupt enable for OUT endpoint 1."]
# [inline (always)]
pub const fn int_out1e (self) -> crate :: common :: Reg < regs :: IntOut1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x09usize) as _) } } # [doc = "Interrupt enable for IN endpoint 1."]
# [inline (always)]
pub const fn int_in1e (self) -> crate :: common :: Reg < regs :: IntIn1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0ausize) as _) } } # [doc = "USB frame number and endpoint index."]
# [inline (always)]
pub const fn frame (self) -> crate :: common :: Reg < regs :: Frame , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0cusize) as _) } } # [doc = "Selected endpoint index."]
# [inline (always)]
pub const fn index (self) -> crate :: common :: Reg < regs :: Index , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x0eusize) as _) } } # [doc = "Endpoint 0 control and status register."]
# [inline (always)]
pub const fn ep0_csr (self) -> crate :: common :: Reg < regs :: Ep0Csr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x10usize) as _) } } # [doc = "Data count for endpoint 0."]
# [inline (always)]
pub const fn ep0_count (self) -> crate :: common :: Reg < regs :: Ep0Count , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x11usize) as _) } } # [doc = "Control and status register for IN endpoints."]
# [inline (always)]
pub const fn in_csr2 (self) -> crate :: common :: Reg < regs :: InCsr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x14usize) as _) } } # [doc = "Control and status register for IN endpoints."]
# [inline (always)]
pub const fn in_csr1 (self) -> crate :: common :: Reg < regs :: InCsr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x15usize) as _) } } # [doc = "Maximum packet size for IN endpoints."]
# [inline (always)]
pub const fn max_pkt_in (self) -> crate :: common :: Reg < regs :: MaxPkt , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x16usize) as _) } } # [doc = "Control and status register for OUT endpoints."]
# [inline (always)]
pub const fn out_csr2 (self) -> crate :: common :: Reg < regs :: OutCsr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x18usize) as _) } } # [doc = "Control and status register for OUT endpoints."]
# [inline (always)]
pub const fn out_csr1 (self) -> crate :: common :: Reg < regs :: OutCsr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x19usize) as _) } } # [doc = "Maximum packet size for OUT endpoints."]
# [inline (always)]
pub const fn max_pkt_out (self) -> crate :: common :: Reg < regs :: MaxPkt , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x1ausize) as _) } } # [doc = "Data count for OUT endpoints."]
# [inline (always)]
pub const fn out_count (self) -> crate :: common :: Reg < regs :: OutCount , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x1cusize) as _) } } # [doc = "FIFO for endpoints."]
# [inline (always)]
pub const fn fifo (self , n : usize) -> crate :: common :: Reg < regs :: Fifo , crate :: common :: RW > { assert ! (n < 6usize) ; unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0x20usize + n * 4usize) as _) } } } pub mod regs { # [doc = "USB Address Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Addr (pub u8) ; impl Addr { # [doc = "Function Address."]
# [inline (always)]
pub const fn addr (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x7f ; val as u8 } # [doc = "Function Address."]
# [inline (always)]
pub fn set_addr (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x7f << 0usize)) | (((val as u8) & 0x7f) << 0usize) ; } # [doc = "Address update flag. Set when a new address is written, cleared after transfer ends."]
# [inline (always)]
pub const fn update (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Address update flag. Set when a new address is written, cleared after transfer ends."]
# [inline (always)]
pub fn set_update (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize) ; } } impl Default for Addr { # [inline (always)]
fn default () -> Addr { Addr (0) } } # [doc = "USB Endpoint 0 Data Count Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ep0Count (pub u8) ; impl Ep0Count { # [doc = "Length of received data in IN packet."]
# [inline (always)]
pub const fn count (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x7f ; val as u8 } # [doc = "Length of received data in IN packet."]
# [inline (always)]
pub fn set_count (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x7f << 0usize)) | (((val as u8) & 0x7f) << 0usize) ; } } impl Default for Ep0Count { # [inline (always)]
fn default () -> Ep0Count { Ep0Count (0) } } # [doc = "USB Endpoint 0 Control and Status Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ep0Csr (pub u8) ; impl Ep0Csr { # [doc = "Indicates that an OUT packet has been received."]
# [inline (always)]
pub const fn out_pkt_rdy (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Indicates that an OUT packet has been received."]
# [inline (always)]
pub fn set_out_pkt_rdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize) ; } # [doc = "Indicates that an IN packet is ready for transmission."]
# [inline (always)]
pub const fn in_pkt_rdy (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Indicates that an IN packet is ready for transmission."]
# [inline (always)]
pub fn set_in_pkt_rdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize) ; } # [doc = "Indicates that a STALL handshake was sent."]
# [inline (always)]
pub const fn sent_stall (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Indicates that a STALL handshake was sent."]
# [inline (always)]
pub fn set_sent_stall (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize) ; } # [doc = "Indicates the end of data stage in control transfer."]
# [inline (always)]
pub const fn data_end (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Indicates the end of data stage in control transfer."]
# [inline (always)]
pub fn set_data_end (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize) ; } # [doc = "Indicates the end of a setup stage in control transfer."]
# [inline (always)]
pub const fn setup_end (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Indicates the end of a setup stage in control transfer."]
# [inline (always)]
pub fn set_setup_end (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize) ; } # [doc = "Sends a STALL handshake."]
# [inline (always)]
pub const fn send_stall (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Sends a STALL handshake."]
# [inline (always)]
pub fn set_send_stall (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize) ; } # [doc = "Clears OutPktRdy flag."]
# [inline (always)]
pub const fn serviced_out_pkt_rdy (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Clears OutPktRdy flag."]
# [inline (always)]
pub fn set_serviced_out_pkt_rdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize) ; } # [doc = "Clears SetupEnd flag."]
# [inline (always)]
pub const fn serviced_setup_end (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Clears SetupEnd flag."]
# [inline (always)]
pub fn set_serviced_setup_end (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize) ; } } impl Default for Ep0Csr { # [inline (always)]
fn default () -> Ep0Csr { Ep0Csr (0) } } # [doc = "USB Endpoint FIFO Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Fifo (pub u8) ; impl Fifo { # [doc = "FIFO data for each endpoint."]
# [inline (always)]
pub const fn data (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "FIFO data for each endpoint."]
# [inline (always)]
pub fn set_data (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u8) & 0xff) << 0usize) ; } } impl Default for Fifo { # [inline (always)]
fn default () -> Fifo { Fifo (0) } } # [doc = "USB Frame Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Frame (pub u8) ; impl Frame { # [doc = "Frame number of the last received frame."]
# [inline (always)]
pub const fn framenum (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Frame number of the last received frame."]
# [inline (always)]
pub fn set_framenum (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u8) & 0xff) << 0usize) ; } } impl Default for Frame { # [inline (always)]
fn default () -> Frame { Frame (0) } } # [doc = "USB IN Endpoint Control and Status Register 1."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct InCsr1 (pub u8) ; impl InCsr1 { # [doc = "Indicates that an IN packet is ready to be sent."]
# [inline (always)]
pub const fn in_pkt_rdy (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Indicates that an IN packet is ready to be sent."]
# [inline (always)]
pub fn set_in_pkt_rdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize) ; } # [doc = "Indicates that the FIFO contains data."]
# [inline (always)]
pub const fn fifo_not_empty (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Indicates that the FIFO contains data."]
# [inline (always)]
pub fn set_fifo_not_empty (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize) ; } # [doc = "Indicates that an underrun condition occurred."]
# [inline (always)]
pub const fn underrun (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Indicates that an underrun condition occurred."]
# [inline (always)]
pub fn set_underrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize) ; } # [doc = "Flushes the FIFO content."]
# [inline (always)]
pub const fn flush_fifo (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Flushes the FIFO content."]
# [inline (always)]
pub fn set_flush_fifo (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize) ; } # [doc = "Sends a STALL handshake for the IN endpoint."]
# [inline (always)]
pub const fn send_stall (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Sends a STALL handshake for the IN endpoint."]
# [inline (always)]
pub fn set_send_stall (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize) ; } # [doc = "Indicates that a STALL handshake was sent."]
# [inline (always)]
pub const fn sent_stall (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Indicates that a STALL handshake was sent."]
# [inline (always)]
pub fn set_sent_stall (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize) ; } # [doc = "Clears the endpoint's data toggle bit."]
# [inline (always)]
pub const fn clr_data_tog (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Clears the endpoint's data toggle bit."]
# [inline (always)]
pub fn set_clr_data_tog (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize) ; } } impl Default for InCsr1 { # [inline (always)]
fn default () -> InCsr1 { InCsr1 (0) } } # [doc = "IN Endpoint Control Register 2."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct InCsr2 (pub u8) ; impl InCsr2 { # [doc = "Force Data Toggle. Forces toggle even without ACK and clears FIFO."]
# [inline (always)]
pub const fn frc_data_tog (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Force Data Toggle. Forces toggle even without ACK and clears FIFO."]
# [inline (always)]
pub fn set_frc_data_tog (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize) ; } # [doc = "DMA request enable for IN endpoint."]
# [inline (always)]
pub const fn dmae (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "DMA request enable for IN endpoint."]
# [inline (always)]
pub fn set_dmae (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize) ; } # [doc = "Endpoint mode. 1, IN endpoint, 0, OUT endpoint."]
# [inline (always)]
pub const fn mode (& self) -> super :: vals :: Mode { let val = (self . 0 >> 5usize) & 0x01 ; super :: vals :: Mode :: from_bits (val as u8) } # [doc = "Endpoint mode. 1, IN endpoint, 0, OUT endpoint."]
# [inline (always)]
pub fn set_mode (& mut self , val : super :: vals :: Mode) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val . to_bits () as u8) & 0x01) << 5usize) ; } # [doc = "Enable ISO transmission. 1, ISO mode, 0, Bulk or Interrupt mode."]
# [inline (always)]
pub const fn iso (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Enable ISO transmission. 1, ISO mode, 0, Bulk or Interrupt mode."]
# [inline (always)]
pub fn set_iso (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize) ; } # [doc = "When set, automatically sets InPktRdy when the maximum packet size is written to the FIFO."]
# [inline (always)]
pub const fn auto_set (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "When set, automatically sets InPktRdy when the maximum packet size is written to the FIFO."]
# [inline (always)]
pub fn set_auto_set (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize) ; } } impl Default for InCsr2 { # [inline (always)]
fn default () -> InCsr2 { InCsr2 (0) } } # [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Index (pub u8) ; impl Index { # [doc = "Endpoint selection index."]
# [inline (always)]
pub const fn index (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "Endpoint selection index."]
# [inline (always)]
pub fn set_index (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u8) & 0x0f) << 0usize) ; } } impl Default for Index { # [inline (always)]
fn default () -> Index { Index (0) } } # [doc = "USB IN Endpoint Interrupt Status Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct IntIn1 (pub u8) ; impl IntIn1 { # [doc = "Endpoint 0 interrupt."]
# [inline (always)]
pub const fn ep0 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Endpoint 0 interrupt."]
# [inline (always)]
pub fn set_ep0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize) ; } # [doc = "Endpoint n+1 IN interrupt."]
# [inline (always)]
pub const fn epin (& self , n : usize) -> bool { assert ! (n < 5usize) ; let offs = 1usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Endpoint n+1 IN interrupt."]
# [inline (always)]
pub fn set_epin (& mut self , n : usize , val : bool) { assert ! (n < 5usize) ; let offs = 1usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u8) & 0x01) << offs) ; } } impl Default for IntIn1 { # [inline (always)]
fn default () -> IntIn1 { IntIn1 (0) } } # [doc = "USB OUT Endpoint Interrupt Status Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct IntOut1 (pub u8) ; impl IntOut1 { # [doc = "Endpoint n+1 OUT interrupt."]
# [inline (always)]
pub const fn epout (& self , n : usize) -> bool { assert ! (n < 5usize) ; let offs = 1usize + n * 1usize ; let val = (self . 0 >> offs) & 0x01 ; val != 0 } # [doc = "Endpoint n+1 OUT interrupt."]
# [inline (always)]
pub fn set_epout (& mut self , n : usize , val : bool) { assert ! (n < 5usize) ; let offs = 1usize + n * 1usize ; self . 0 = (self . 0 & ! (0x01 << offs)) | (((val as u8) & 0x01) << offs) ; } } impl Default for IntOut1 { # [inline (always)]
fn default () -> IntOut1 { IntOut1 (0) } } # [doc = "USB Interrupt Status Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct IntUsb (pub u8) ; impl IntUsb { # [doc = "Suspend signal detected on USB bus."]
# [inline (always)]
pub const fn suspend (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Suspend signal detected on USB bus."]
# [inline (always)]
pub fn set_suspend (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize) ; } # [doc = "Resume signal detected on USB bus."]
# [inline (always)]
pub const fn resume (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Resume signal detected on USB bus."]
# [inline (always)]
pub fn set_resume (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize) ; } # [doc = "Reset signal detected on USB bus."]
# [inline (always)]
pub const fn reset (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Reset signal detected on USB bus."]
# [inline (always)]
pub fn set_reset (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize) ; } # [doc = "Start-of-frame interrupt."]
# [inline (always)]
pub const fn sof (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Start-of-frame interrupt."]
# [inline (always)]
pub fn set_sof (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize) ; } } impl Default for IntUsb { # [inline (always)]
fn default () -> IntUsb { IntUsb (0) } } # [doc = "USB Endpoint Maximum Packet Size Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct MaxPkt (pub u8) ; impl MaxPkt { # [doc = "Maximum packet size for the endpoint."]
# [inline (always)]
pub const fn max_pkt_size (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Maximum packet size for the endpoint."]
# [inline (always)]
pub fn set_max_pkt_size (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u8) & 0xff) << 0usize) ; } } impl Default for MaxPkt { # [inline (always)]
fn default () -> MaxPkt { MaxPkt (0) } } # [doc = "USB OUT Endpoint Data Count Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct OutCount (pub u8) ; impl OutCount { # [doc = "Length of received data in OUT packet."]
# [inline (always)]
pub const fn count (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Length of received data in OUT packet."]
# [inline (always)]
pub fn set_count (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u8) & 0xff) << 0usize) ; } } impl Default for OutCount { # [inline (always)]
fn default () -> OutCount { OutCount (0) } } # [doc = "USB OUT Endpoint Control and Status Register 1."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct OutCsr1 (pub u8) ; impl OutCsr1 { # [doc = "Indicates that an OUT packet has been received."]
# [inline (always)]
pub const fn out_pkt_rdy (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Indicates that an OUT packet has been received."]
# [inline (always)]
pub fn set_out_pkt_rdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize) ; } # [doc = "Indicates that the FIFO is full."]
# [inline (always)]
pub const fn fifo_full (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Indicates that the FIFO is full."]
# [inline (always)]
pub fn set_fifo_full (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize) ; } # [doc = "Indicates that an overrun condition occurred."]
# [inline (always)]
pub const fn overrun (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Indicates that an overrun condition occurred."]
# [inline (always)]
pub fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize) ; } # [doc = "Indicates that a data error occurred."]
# [inline (always)]
pub const fn data_error (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Indicates that a data error occurred."]
# [inline (always)]
pub fn set_data_error (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize) ; } # [doc = "Flushes the FIFO content."]
# [inline (always)]
pub const fn flush_fifo (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Flushes the FIFO content."]
# [inline (always)]
pub fn set_flush_fifo (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize) ; } # [doc = "Sends a STALL handshake for the OUT endpoint."]
# [inline (always)]
pub const fn send_stall (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Sends a STALL handshake for the OUT endpoint."]
# [inline (always)]
pub fn set_send_stall (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize) ; } # [doc = "Indicates that a STALL handshake was sent."]
# [inline (always)]
pub const fn sent_stall (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Indicates that a STALL handshake was sent."]
# [inline (always)]
pub fn set_sent_stall (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize) ; } # [doc = "Clears the endpoint's data toggle bit."]
# [inline (always)]
pub const fn clr_data_tog (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Clears the endpoint's data toggle bit."]
# [inline (always)]
pub fn set_clr_data_tog (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize) ; } } impl Default for OutCsr1 { # [inline (always)]
fn default () -> OutCsr1 { OutCsr1 (0) } } # [doc = "USB OUT Endpoint Control and Status Register 2."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct OutCsr2 (pub u8) ; impl OutCsr2 { # [doc = "DMA mode for the OUT endpoint."]
# [inline (always)]
pub const fn dma_mode (& self) -> super :: vals :: Dmamode { let val = (self . 0 >> 4usize) & 0x01 ; super :: vals :: Dmamode :: from_bits (val as u8) } # [doc = "DMA mode for the OUT endpoint."]
# [inline (always)]
pub fn set_dma_mode (& mut self , val : super :: vals :: Dmamode) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val . to_bits () as u8) & 0x01) << 4usize) ; } # [doc = "Enables DMA requests for the OUT endpoint."]
# [inline (always)]
pub const fn dmae (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Enables DMA requests for the OUT endpoint."]
# [inline (always)]
pub fn set_dmae (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize) ; } # [doc = "Indicates if the endpoint is configured for ISO transfer."]
# [inline (always)]
pub const fn iso (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Indicates if the endpoint is configured for ISO transfer."]
# [inline (always)]
pub fn set_iso (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize) ; } # [doc = "Automatically clears OutPktRdy after data is read from the FIFO."]
# [inline (always)]
pub const fn auto_clear (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Automatically clears OutPktRdy after data is read from the FIFO."]
# [inline (always)]
pub fn set_auto_clear (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize) ; } } impl Default for OutCsr2 { # [inline (always)]
fn default () -> OutCsr2 { OutCsr2 (0) } } # [doc = "USB Power Management Register."]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Power (pub u8) ; impl Power { # [doc = "Enable suspend functionality."]
# [inline (always)]
pub const fn enable_suspend (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Enable suspend functionality."]
# [inline (always)]
pub fn set_enable_suspend (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize) ; } # [doc = "Indicates if the USB device is in suspend mode."]
# [inline (always)]
pub const fn suspend_mode (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Indicates if the USB device is in suspend mode."]
# [inline (always)]
pub fn set_suspend_mode (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize) ; } # [doc = "Resumes the USB device from suspend mode when set by software."]
# [inline (always)]
pub const fn resume (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Resumes the USB device from suspend mode when set by software."]
# [inline (always)]
pub fn set_resume (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize) ; } # [doc = "Indicates if there is a reset signal on the USB bus."]
# [inline (always)]
pub const fn reset (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Indicates if there is a reset signal on the USB bus."]
# [inline (always)]
pub fn set_reset (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize) ; } # [doc = "Forces the USB controller to wait for a SOF before sending a data packet."]
# [inline (always)]
pub const fn iso_update (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Forces the USB controller to wait for a SOF before sending a data packet."]
# [inline (always)]
pub fn set_iso_update (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize) ; } } impl Default for Power { # [inline (always)]
fn default () -> Power { Power (0) } } } pub mod vals { # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Dmamode { DMAANDIT = 0x0 , DMAORIT = 0x01 , } impl Dmamode { # [inline (always)]
pub const fn from_bits (val : u8) -> Dmamode { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Dmamode { # [inline (always)]
fn from (val : u8) -> Dmamode { Dmamode :: from_bits (val) } } impl From < Dmamode > for u8 { # [inline (always)]
fn from (val : Dmamode) -> u8 { Dmamode :: to_bits (val) } } # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Mode { OUT = 0x0 , IN = 0x01 , } impl Mode { # [inline (always)]
pub const fn from_bits (val : u8) -> Mode { unsafe { core :: mem :: transmute (val & 0x01) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Mode { # [inline (always)]
fn from (val : u8) -> Mode { Mode :: from_bits (val) } } impl From < Mode > for u8 { # [inline (always)]
fn from (val : Mode) -> u8 { Mode :: to_bits (val) } } }